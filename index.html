<h1>PicoJava Description</h1>
<p>This is an example JastAdd project that implements static-semantic checking for a tiny object-oriented language, "PicoJava". PicoJava illustrates essential parts of name resolution for OO languages, including inheritance, nesting, and qualified access. PicoJava also illustrates essential parts of OO type analysis, including dealing with type hierarchies in checking assignments.</p> 

<p>In the following, the PicoJava language is described in a two-column format: informal description to the left and JastAdd implementation comments to the right.</p>

<table border="1" cellpadding="5">
  <tbody><tr>
    <td><b>Informal description of PicoJava</b></td>
    <td><b>JastAdd implementation of the PicoJava compiler</b></td>
  </tr>
  <tr>
    <td valign="TOP" width="50%"> <!--INFORMAL OVERVIEW-->
        <p>The PicoJava language is designed to be able to illustrate the essential parts of name resolution and type analysis for object-oriented languages. </p>
        <p>PicoJava supports single inheritance of classes. Classes can also be nested inside each other (like inner classes in Java). Name resolution thus has to deal with a combination of inheritance and nesting.</p>
        <p>A PicoJava class can contain variables and statements. These constructs suffice to be able to illustrate important type checking problems, e.g., dealing with type hierarchies in assignment.</p>
        <p>PicoJava variables can be accessed using qualified access. This illustrates the interdependences between name resolution and type analysis.</p>
        <p>Note that PicoJava is only intended as a language for illustrating typical static semantics problems. It would need to be complemented with many additional language features in order to be able to express meaningful executable programs. For example, there are no methods in PicoJava, and no "new" expressions. These can easily be added, but do not contribute to illustrating the fundamental issues in static semantics mentioned above.</p>
         <p>The following example programs illustrate a legal and an illegal picojava program:</p>
      <ul>
        <li><b>examples/legal.pj</b></li>
        <li><b>examples/illegal.pj</b></li>
      </ul>
      The illegal program illustrates a number of static-semantic errors.
    
    </td>
    <td valign="TOP"> <!-- JASTADD OVERVIEW-->
       <p><b>The Compiler tool</b></p>
      <p>
      The tool Compiler is built using the AST classes generated by JastAdd. Run it with the following
      command:</p> 
      <pre>   java -cp tools/beaver-rt.jar:. Compiler <i>PicoJava-program</i>
      </pre>
      
      <p><b>Implementation overview</b></p>
      <p>
      Scanning and parsing is implemented using the third-party tools Flex and Beaver. The main program is written
      in Java. The rest of the tool
      (name resolution, type analysis, error checking, etc.) is implemented using JastAdd.
      Tests are implemented using the JUnit framework.</p>
      <p>
      The implementation is structured into the following files:
      </p>
      <p><b>Main program</b></p>
      <ul>
        <li><b>Compiler.java</b>: Simply parses the input file and prints
        error messages. All the static-semantics is performed implicitly as needed when the error-checking computation
        accesses the
        AST and its attributes.</li>
      </ul>
      <p><b>Scanning and Parsing</b></p>
       <ul>
        <li><b>picojava.flex</b>: Input to flex. See
        <b>tests/ScannerTests.java</b>
        for examples of legal and illegal tokens.</li>
        <li><b>picojava.parser</b>: Input to beaver.
        Uses semantic actions to construct the AST. See <b>tests/ParserTests.java</b>
        for small examples of syntactially legal and illegal programs. Example programs can be found in the
        other test cases as well.</li>
      </ul>
      <p><b>Abstract Syntax</b></p>
      <ul>
        <li><b>picojava.ast</b>: Defines the abstract syntax as classes.</li>
      </ul>
      <p><b>Static Semantics</b></p>
       <ul>
       <li><b>NameResolution.jrag</b>:
         Defines name resolution for the PicoJava language.
         Uses reference attributes to bind accessed names to their declarations. Also illustrates parameterized
         attributes and broadcasting.</li>
         <li><b>TypeAnalysis.jrag</b>: Uses reference attributes to bind each expression to a type object.
         Also illustrates double dispatching, rewrites, and circular attributes.</li>
        <li><b>PredefinedTypes.jrag</b>: Uses nonterminal attributes to add
        predefined types like boolean and class Object to the AST.</li>
        <li><b>NullObjects.jrag</b>: Uses the Null design pattern to simplify type comparisons for undeclared accesses.</li>
      </ul>
      <p><b>Checking errors</b></p>
      <ul>
        <li><b>ErrorCheck.jadd</b>: An imperative aspect that prints out error messages based on the information
        computed in the NameResolution and TypeAnalysis aspects.</li>
      </ul>
    </td>
  </tr>
</tbody></table>


<h2>Abstract syntax</h2>
<table border="1" cellpadding="5">
  <tbody>
    <tr>
        <td valign="TOP" width="50%"> 
            <p>A PicoJava program consists of a block with declarations and statements in it.</p>
            <p>There are two main kinds of declarations: classes and variables.</p>
            <p>A class can optionally inherit from another class.
            <!--If no superclass is given explicitly, the class inherits from the predefined class Object.--> </p>
            <p>A variable has a type which is either a class type or the primitive predefined type <i>boolean</i>.</p>
            <p>A class has a body which is a block. Note that classes can be nested since a class can be declared inside the body of another class.</p>
            <p>The statements in a block can be assignments or while statements.</p>
            <p>Variables in other objects can be accessed using ordinary qualified access (dot-notation).</p>
        </td>
        <td valign="TOP">
        <p>The <b>abstract syntax</b> is defined in <b>picojava.ast</b>.</p>
        <p><b>Predefined types</b> are handled by inserting explicit declarations for them into the AST, as children
        of the Program root node. This is implemented by a list nonterminal attribute, whose value is defined by an equation.
        The AST nodes for the predefined types are thus not created by the parser, they are instead created automatically by the
        attribute evaluator. </p>
    <p>
     The nonterminal attribute is defined in  <b>PredefinedTypes.jrag</b>
     as a synthesized attribute, and its defining equation creates a type declaration for "boolean,
     and also an object of type UnknownDecl which is used for missing declarations and types.  
     </p>
     <p>
     In order to be able to refer to the object representing "boolean", a reference attribute named "booleanType"
     is broadcast using an
     inherited attribute and exposed at various places where it is needed.
     </p>
    </td>
  </tr>
</tbody></table>

<h2>Name resolution</h2>
<table border="1" cellpadding="5">
  <tbody><tr>
    <td valign="TOP" width="50%"> <!--INFORMAL: NAME RESOLUTION-->
      The goal of name resolution is to find out which declaration each accessing name refers to.
    </td>
    <td valign="TOP"> <!--JASTADD: NAME RESOLUTION-->
      <p>
      The name resolution is defined in the aspect <b>NameResolution.jrag</b>.
      For each Access node, an attribute <b>decl()</b> is defined which refers to the appropriate Decl node.
      If there is no matching declaration, the decl() attribute will be the UnknownDecl, applying the Null design
      pattern.
      </p>
      <p>The decl() attribute constitutes the
      <b>API of the name resolution module</b> that is useful for other aspects to access. For example, the type checker
      can use the decl() attribute in order to find the type of an Access.
       </p>
    </td>
  </tr>
  <tr>
    <td valign="TOP" width="50%"> <!--INFORMAL: BASIC SCOPE RULES-->
    PicoJava has the following basic scope rules:
    <ul>
      <li>Usual <b>nesting</b> applies: Names declared in an outer block are
      visible also in inner blocks, unless
      shadowed by a declaration of the same name in the inner block.</li>
      <li><b>Order of declaration is irrelevant</b> within a block. This is
      slightly different from ordinary Java where the order is irrelevant only for methods and classes, but not for
      variables. In PicoJava, a variable declared inside a block is visible also to statements above it in
      the block body.</li>
    </ul>
    </td>
    <td valign="TOP"> <!--JASTADD: BASIC SCOPE RULES-->
      <p>
      Basic name resolution is implemented by two attributes:
      </p><ul>
        <li>Synthesized attributes <b>localLookup(String)</b> which are defined for constructs
                that contain declarations,
                e.g., Block. This attribute searches through the local declarations to find one with a given name. 
                The position of the access is not taken into account, so the <b>order
                of declaration is irrelevant</b> within a block.</li>
        <li>Inherited attributes <b>lookup(String)</b> which return the visible declaration of a given name.
        IdUse calls lookup(String) to find its declaration.
        Constructs that control scope rules define the lookup attribute for their children, typically by delegating
        to localLookup attributes, and to their own lookup attribute defined by the context. A Block defines
        lookup(String) by delegating first to its own localLookup (searching through local declarations), and then
        to its own lookup. This way ordinary <b>nesting</b> is implemented.
      </li></ul>
      Test cases for basic name resolution are found in <b>tests/BasicNameResolutionTests.java</b>
      <p></p>
    </td>
  </tr>
    <tr>
    <td valign="TOP" width="50%"> <!--INFORMAL: INHERITANCE-->
    PicoJava supports object-oriented inheritance in combination with block nesting:
    <ul>
       <li>
          <b>Inheritance</b>: Names declared in a class are visible also in subclasses.
       </li>
       <li>
         <b>Combining inheritance and nesting</b>:
         For a class nested inside a block, the declarations in the superclasses will shadow declarations
         in the outer block that have the same name.
       </li>
    </ul>
    </td>
    <td valign="TOP"> <!--JASTADD: INHERITANCE-->
      <ul>
        <li>
      To implement <b>inheritance</b>, each ClassDecl has a synthesized attribute
      <b>remoteLookup(String)</b> which looks through the declarations of the class and (if needed)
      declarations in the superclasses. This attribute is intended for handling lookup from accesses inside
      subclasses and from qualified accesses.
        </li>
        <li>
          To <b>combine inheritance with nesting</b>, each ClassDecl defines <b>lookup(String)</b> to first look in the
          superclass chain (using the remoteLookup(String) attribute), before looking in the surrounding context.
        </li>
      </ul>
      <p>Test cases for inheritance are found in
      <b>tests/InheritanceNameResolutionTests.java</b>.
    </p></td>
  </tr>
  <tr>
    <td valign="TOP" width="50%"> <!--INFORMAL: QUALIFIED ACCESS-->
    PicoJava supports <b>qualified access</b>. I.e., an expression "a.b" means that "b" is an entity in the object
    referred to by "a".
    </td>
    <td valign="TOP"> <!--JASTADD: QUALIFIED ACCESS-->
   <p> To implement <b>qualified access</b>, a Dot redefines <b>lookup(String)</b> for its right-hand identifier.
     Instead of searching in the context, a remote lookup is done on the object's type.
    </p><p> Test cases for qualified access are found in
      <b>tests/DotNameResolutionTests.java</b>
    </p>
    </td>
  </tr>
</tbody></table>

<h2>Type Analysis</h2>
<table border="1" cellpadding="5">
  <tbody>
    <tr>
      <td valign="TOP" width="50%"> 
        <p>The main goal of type analysis is to find the type of each expression.</p>
      </td>
      <td valign="TOP"> 
        <p>The type analysis is defined in the aspect <b>TypeAnalysis.jrag</b>.</p>
        <p>The <b>API of the type analysis module</b> consists of the following attributes</p>
        <ul>
          <li>Expressions and declarations have a <b>type()</b> attribute that is a reference to the appropriate type declaration. If there is no such appropriate declaration, the type() attribute will be the  UnknownDecl, applying the Null design pattern.</li>
          <li>Type declarations have a parameterized attribute <b>subtypeOf(TypeDecl)</b> which compares the two types.</li>
          <li>Expressions have a boolean attribute <b>isValue()</b> which is true if the expression denotes a value i.e., something that can be stored in a variable.</li>
          <li>Classes have a boolean attribute <b>hasCycleOnSuperclassChain()</b> that is true if there is a cycle somewhere on the superclass chain.</li>
          <li>Classes have a ClassDecl attribute <b>superClass</b> that refers to the superclass declaration if it exists and is appropriate, e.g., without any cycles on the superclass chain, otherwise this attribute is null.</li>
        </ul>
        <p>Test cases for the type analysis are found in <b>tests/TypeAnalysisTests.java</b>.</p>
      </td>
    </tr>
    <tr>
    <td valign="TOP" width="50%"> <!--INFORMAL: Subtyping-->
    A class is a <b>subtype</b> of another class if it is a direct or indirect subclass.
    The subtype relation is inclusive, i.g., a class is considered to be a subtype of itself.
    </td>
    <td valign="TOP"> <!--JASTADD: Subtyping-->
    <p>The subtype relation is implemented using the parameterized attribute <b>subtypeOf(TypeDecl)</b>. The
    implementation is done via <b>double dispatching</b>. I.e., for each subclass X of TypeDecl,
    another attribute supertypeOfX(TypeDecl) is introduced which is called in X's implementation of subtypeOf,
    reversing the argument and the receiver.</p>
    <p>The double dispatching provides an open way of implementing the comparison:
    New kinds of TypeDecls can be introduced without having to change 
    the TypeAnalysis.jrag module. For example, to add the Null object UnknownDecl, its type comparison with other
    TypeDecls could be added completely inside the module NullObjects.jrag.</p>
    </td>
  </tr>
  <tr>
    <td valign="TOP" width="50%"> <!--INFORMAL: CYCLIC-->
    Class hierarchies must not be cyclic. I.e., a class may not (directly or indirectly) extend itself.
    </td>
    <td valign="TOP"> <!--JASTADD: CYCLIC-->
    The definition of the attribute <b>hasCycleOnSuperclassChain()</b> makes use of the circular attribute feature,
    i.e., it is defined in terms of other hasCycleOnSuperclassChain() attributes, and ultimately, it may be defined
    in terms of itself (if there actually is a cycle in the class hierarchy). To guarantee termination of circular attributes,
    the possible values should be on a lattice of finite height, and the equations monotonic, i.e., change the values
    only upwards in the lattice. In this case, we have a boolean lattice with TRUE at the bottom (the start value),
    and FALSE at the top. We see that the equations are monotonic since the values can go up to FALSE, but there is no
    equation that can bring the value down to TRUE.
    </td>
  </tr>
  <tr>
    <td valign="TOP" width="50%"> <!--INFORMAL: SECTION-->
    Depending on the declaration of an accessed identifier, it can be either an access to a variable or an access to a type.
    </td>
    <td valign="TOP"> <!--JASTADD: SECTION-->
    <p>
    When the parser constructs the initial AST, it cannot know the declarations of the accessed identifiers, so it constructs
    Use nodes for all accessed identifiers. After name resolution, however, the declaration is known. It is useful to then
    replace the Use node with more specialized nodes: VarUse or TypeUse, depending on if the declaration is a variable
    or a type declaration. This is specified by two context-dependent <b>rewrite rules</b> in the type analysis module.
    </p>
    <p>The replacement of Use nodes by VarUse or TypeUse, simplifies other computations and supports
    extensibility. We can see this in the computation of the isValue() attribute.
    Without the rewrite, this attribute would have to
    be defined by testing the type of the decl() attribute (using instanceof). If we later on extend the language with more kinds of
    declarations, the definition of the isValue() attribute might need to be changed. But with the rewriting solution,
    we can simply add a rewrite for the corresponding new kind of use, and add an isValue() equation for that class.</p>
    </td>
  </tr>
</tbody></table>

<h2>Null objects</h2>
<table border="1" cellpadding="5">
  <tbody><tr>
    <td valign="TOP" width="50%"> <!--INFORMAL: NULL OBJECTS-->
    It is desirable that static-semantic errors in a PicoJava program do not lead to
    additional errors. For example, if a declaration is missing, it is sufficient to mark
    the access as having a missing declaration - additional messages about type errors are undesirable.
    </td>
    <td valign="TOP"> <!--JASTADD: NULL OBJECTS-->
    <p>We apply the Null design pattern to missing declarations and other situations where there are
    static-semantic errors. I.e., instead of representing a missing declaration as null, it is represented
    by a singleton UnknownDecl object. UnknownDecl is also used for representing inappropriate accesses,
    e.g., accessing a variable name where a class name is expected. </p><p>
    </p><p>The UnknownDecl should be compatible with everything in order to not generate meaningless
    error messages. So it is defined to be both a supertype and a subtype of other types. Thanks to the double
    dispatching discussed above, it is possible to define this completely within the
    <b>NullObjects.jrag</b> module, rather
    than having to change the Type Resolution module.</p>
    <p>
    The singleton UnknownDecl object is created by an NTA equation and placed in the list of predefined
    declarations in the root of the AST. A reference to the object is broadcast through the AST, and exposed
    at the various places in the AST where it is needed.
    </p>
    </td>
  </tr>
</tbody></table>

<h2>Error checking</h2>
<table border="1" cellpadding="5">
  <tbody><tr>
    <td valign="TOP" width="50%"> <!--INFORMAL: ERROR CHECKING-->
    There are various kinds of possible static-semantic errors in PicoJava. E.g., use of unknown identifiers,
    incompatible types in assignments, cycles in the class hierarchy, and type-checking of conditions in while-loops.
    </td>
    <td valign="TOP"> <!--JASTADD: ERROR CHECKING-->
    <p>Errorchecking is implemented by an imperative module <b>ErrorCheck.jadd</b>.
    The API contains a method <b>errors()</b> for the Program (root) node. This method simply traverses the AST and
    collects error messages in a Collection object that is returned, using the attributes in the API:s of the
    static-semantics modules. </p>
    <p>
       Test cases for the error checking are found in
        <b>tests/ErrorCheckTests.java</b>. 
     </p>
    </td>
  </tr>
</tbody></table>

<h2>Building the tool</h2>
<p>
This project also contains all tools needed to build the PicoJava compiler.
</p>
<ul>
   <li><b>tests</b>: package containing JUnit test cases.
    </li>
   <li><b>testframework</b>: package containing classes useful for
   testing
   
   <ul>
      <li><b><i>TestAll.java</i></b>:
      Used for finding all testcases when running tests from a
      terminal window.</li>
   </ul>
   </li>
   
    <li><b>tools</b>: directory containing all the tools you need to
   run this JastAdd project
   </li>
   
   <li><b>build.xml</b>: Ant build file to be
   used from a terminal window or from Eclipse
   
   <ul>
      <li>Use the targets <i>build</i> (default), <i>test</i>, and
      <i>clean</i>, when working from a terminal window. For example,
      type<table border="1">
         <tbody><tr>
            <td>
               <pre>ant</pre>
            </td>
            <td>
               <p>generate all java files and compile them</p>
            </td>
         </tr>
         <tr>
            <td>
               <pre>ant test</pre>
            </td>
            <td>
               <p>run all test cases</p>
            </td>
         </tr>
         <tr>
            <td>
               <pre>ant clean</pre>
            </td>
            <td>
               <p>remove all generated files and all the class files
               for both generated and handwritten java files</p>
            </td>
         </tr>
      </tbody></table>
      </li>
      <li>Use the targets <i>gen</i> and <i>cleanGen</i> when working
      from eclipse (see <a href="http://jastadd.cs.lth.se/web/manual/eclipse.shtml">Running
      JastAdd Under Eclipse</a>):<table border="1">
         <tbody><tr>
            <td>
               <pre>ant gen</pre>
            </td>
            <td>
               <p>generate all java files</p>
            </td>
         </tr>
         <tr>
            <td>
               <pre>ant cleanGen</pre>
            </td>
            <td>
               <p>remove all generated files and their class
               files.</p>
            </td>
         </tr>
      </tbody></table>
      </li>
   </ul>
   </li>
   
   <li><b>AST</b>: package containing files generated by the tools. This directory is not present when the
   project is "clean". The directory will contain parser files
   generated by parser generator and AST files generated by JastAdd.</li>
   

   <!--
   <LI><A HREF="release.txt"><I>release.txt</I></A> Release and
   version information about the example</LI>
   -->
</ul>

